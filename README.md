# CPU 스케줄링 시뮬레이터 보고서
**2021320080 박태규**

## 1. 서론

### 1.1 CPU 스케줄러란?
CPU 스케줄러는 운영체제의 핵심 구성요소로서, 여러 프로세스 중에서 어떤 프로세스가 CPU를 사용할지를 결정하는 시스템이며, 멀티프로그래밍 환경에서 CPU가 Idle 상태가 되는 것을 최대한 막아 CPU 가동 시간을 늘려 시스템 성능을 높이기 위해 필요하다.

CPU 스케줄러는 프로세스의 상태가 바뀌거나 I/O Interupt가 발생함에 따라 현재 실행하고 있는 프로세스 대신 다른 대기중인 프로세스를 선택할 수 있으며, 이 때 스케줄링 알고리즘이 다음에 올 프로세스를 결정한다. 시스템의 특성과 요구사항에 따라 스케줄링 알고리즘의 성능이 달라질 수 있으므로 알맞은 스케줄링 알고리즘을 정해야한다.

### 1.2 직접 구현한 스케줄러의 특징
CPU 스케줄링 시뮬레이터 실행 시 시스템과 그 안의 프로세스에 대한 정보를 임의로 할당하여 시뮬레이션을 진행할 수 있게 하고 이 때 각 프로세스에는 CPU 작업뿐만 아니라 I/O 작업관련 정보들도 랜덤으로 할당한다. 그 다음 구현한 스케줄링 알고리즘 6가지에 대해 프로세스를 전부 실행해보며 간트 차트를 그리고 반환 시간과 대기 시간을 계산하여 프로세스들에 대한 각 스케줄링 알고리즘의 성능을 비교할 수 있게 한다.

구현된 스케줄러의 주요 특징은 다음과 같습니다.

1.  **준비 큐와 대기 큐를 원형 큐로 구현:** 일반 선형 큐는 큐에서 마지막 인덱스에 도달하면 더이상 프로세스를 큐에 넣을 수 없어 큐의 크기를 늘려야하는데 원형 큐의 경우 큐의 마지막 인덱스에 새로운 프로세스를 넣으려해도 맨 앞 인덱스에 넣을 수 있어 전체 큐 용량을 효율적으로 사용할 수 있어 메모리를 아낄 수 있다.
2.  **CPU 버스트 크기에 맞춘 I/O 작업 수 제한:** 작업 시간의 최소 단위가 1이므로 CPU 버스트 시간보다 I/O 작업 요청 수가 더 많으면 진행되지 않는 I/O가 반드시 생기기 때문에 이를 제한한다.

---

## 2. 본론

### 2.1 다른 CPU 스케줄링 시뮬레이터에 대한 소개
AnimOS CPU-Scheduling은 독일 도르트문트 대학에서 개발한 웹 기반 시각화 도구로, 운영체제 내부 동작을 애니메이션으로 보여준다. 이 시뮬레이터는 단계별 실행 제어, 사용자 정의 스케줄링 전략 구현, 그리고 직관적인 간트 차트를 제공한다. 특히 교육 목적으로 설계되어 학생들이 다음 단계를 예측해볼 수 있는 단계별 실행 기능을 지원한다.

### 2.2 본인이 구현한 시뮬레이터의 시스템 구성도

**[주요 데이터 구조]**
* **System 구조체** : 전체 시뮬레이션 환경을 관리하는 최상위 구조체, 모든 프로세스 배열 관리, 준비 큐와 대기 큐 관리, 현재 시스템 시간, 사용 중인 알고리즘, 타임 퀀텀, 간트 차트 정보 등을 포함.
* **Process 구조체** : 각각의 프로세스의 모든 속성을 저장하며, CPU 관련 속성과 I/O 관련 속성을 포함한다.
* **IO 구조체** : IO 작업에 대해 IO 요청 시간과 작업 시간을 묶어 저장한다. I/O 요청 시간을 정렬할 때 작업 시간도 같은 순서로 따라가야하므로 이 구조체를 만들었다.
* **Queue 구조체** : 원형 큐로 구현되어 효율적인 프로세스 삽입과 제거를 지원하며, front, rear 포인터와 현재 크기를 관리한다.
* **Gantt 구조체** : 간트 차트에서 현재 시간에 기록될 작업의 id를 기록한다.

**[전체 시뮬레이터 실행 단계]**
1.  유저로부터 총 프로세스 개수 입력 받기
2.  시스템 초기 설정 : 각 프로세스에 작업 할당, 시스템 환경 관련 변수 초기화
3.  스케줄링 실행 : 6개의 스케줄링 알고리즘 전부 실행
4.  CPU 및 I/O 작업 처리 : 각 프로세스 별 CPU 작업을 처리하면서 I/O 작업 요청이 있는 경우 Interupt처리
5.  성능 측정 : 반환시간, 대기시간 계산
6.  시각화 : 간트 차트 생성

### 2.3 주요 모듈에 대한 설명 (알고리즘으로 표현)

**[SysConfig - 시스템 환경 설정]**
* 사용자로부터 총 프로세스 개수 입력 받기
* 전체 시스템 환경 변수 초기화(알고리즘 기본값 : FCFS, 현재 시간 : 0초, 타임 퀀텀 : 2초)
* 대기 큐, 준비 큐에 메모리 할당하여 초기화
* 입력 값 개수만큼 프로세스 만들기

**[MakeProcess - 프로세스 만들기]**
* 시스템에 있는 프로세스 배열에 프로세스를 생성하면서 cpu 관련 변수들 초기화, i/o 관련 변수들 초기화를 한다. CPU의 작업 시간과 도착 시간은 랜덤으로 한다.
* CPU 버스트 시간에 따라 최대 I/O 요청 가능 횟수를 정하고 I/O 작업을 생성하고 각 I/O작업마다 요청 시간, I/O 버스트 시간을 랜덤으로 할당한다. 이 때 동일한 시간에 I/O가 둘 이상 요청되는 경우를 막는다.

**[RunAllAlgorithms - 모든 알고리즘 실행]**
* 동일한 데이터에 대해 6개의 알고리즘을 실행해야하므로 먼저 시스템, 프로세스, 간트 차트를 초기화 한다.
* 각 알고리즘을 실행하고 각 프로세스에 대해 반환 시간, 대기 시간을 출력한다. 모든 프로세스의 평균 반환 시간, 대기 시간을 출력하고 간트 차트도 출력한다.

**[InitCurRunningProcess - 준비 큐 업데이트 및 현재 실행중인 프로세스 찾기]**
* 현재 시스템 시간에 도착한 프로세스가 있는지 반복문을 순회하며 찾기
* 도착한 프로세스가 있고 준비 큐에 없으면 그 프로세스를 준비 큐에 넣는다
* 모든 프로세스 중에서 상태가 RUNNING인 프로세스를 찾아 반환한다.

**[ExecuteCPU]**
* 프로세스의 CPU 버스트 시간을 1초 줄인다.
* 만약 남은 CPU 버스트 시간이 0초이면 작업이 끝난 것이므로 상태를 TERMINATED로 변경
* 프로세스가 끝났으므로 반환 시간과 대기 시간을 계산한다.

**[HasIORequest - 프로세스가 처리해야할 I/O 작업이 있는 지 확인]**
* I/O 요청 수가 0인 경우 false 반환
* 프로세스가 지금까지 얼마나 진행되었는지 시간을 계산
* I/O 요청 시간과 프로세스 진행 시간이 같아지면 I/O 작업을 실행해야하므로 true 반환
    > (I/O 요청 시간은 시스템 자체의 시간이 아니라 프로세스 진행 시간을 기준으로 하는 것이기 때문이다)

**[HandleIO - I/O 작업 처리]**
* I/O 요청이 없는 경우 처리할 것이 없기 때문에 false 반환
* 대기 큐에서 가장 앞에 있는 프로세스를 꺼내 남은 I/O 버스트 시간을 1 줄인다.
* CPU작업과 마찬가지로 남은 버스트 시간이 0이 되면 I/O작업이 끝난 것이기 때문에 I/O 인덱스를 1 증가시키고 준비 큐에 넣으며 프로세스를 READY상태로 변경한다.
* 만약 남은 버스트 시간이 있다면 꺼낸 프로세스를 다시 대기 큐의 제일 끝에 넣는다.

**[Fcfs, SjfNP, priority_np]**
* 현재 실행 중인 프로세스를 찾는다.
* 현재 실행 중인 프로세스가 없지만 준비 큐에 프로세스가 있는 경우 준비 큐에서 프로세스를 꺼내와서 RUNNING상태로 만든다.
* 준비 큐에서 프로세스를 꺼낼 때 Fcfs인 경우 대기 큐는 먼저 온 순서대로 프로세스가 존재하기 때문에 그냥 꺼내면 되며 SjfNP인 경우 대기 큐를 순회하면서 남은 CPU 버스트 시간이 가장 짧은 작업을 꺼내야하고 priority_np인 경우 마찬가지로 대기 큐를 순회하면서 우선순위가 가장 높은 프로세스를 찾아야한다.
* 실행 중인 프로세스를 찾은 경우 I/O 작업을 해야하면 대기 큐로 옮기고 준비 큐에 프로세스가 있는지 확인한다.
* 준비 큐에 프로세스가 있는 경우 다음 프로세스를 바로 선택한다. 이 때 다음 프로세스를 선택하는 과정 또한 알고리즘에 맞게 수행하고 I/O, CPU 작업을 실행한다.
* 만약 준비 큐에 프로세스가 없는 경우 CPU가 실행할 수 있는 프로세스가 없기 때문에 IDLE처리한다.
* 처음부터 실행 중인 프로세스를 못 찾은 경우도 마찬가지로 IDLE처리한다.
* 최종적으로 간트 차트에 기록한다.

**[SjfP, priority_p]**
* 현재 실행 중인 프로세스를 찾는다.
* 현재 실행 중인 프로세스가 없지만 준비 큐에 프로세스가 있는 경우 준비 큐에서 프로세스를 꺼내와서 RUNNING상태로 만든다.
* 준비 큐에서 프로세스를 꺼낼 때 SjfP인 경우 대기 큐를 순회하면서 남은 CPU 버스트 시간이 가장 짧은 작업을 꺼내야하고 priority_p인 경우 마찬가지로 대기 큐를 순회하면서 우선순위가 가장 높은 프로세스를 찾아야한다.
* 실행 중인 프로세스를 찾은 경우 I/O 작업을 해야하면 대기 큐로 옮기고 준비 큐에 프로세스가 있는지 확인한다.
* 준비 큐에 프로세스가 있는 경우 다음 프로세스를 바로 선택한다. 이 때 다음 프로세스를 선택하는 과정 또한 알고리즘에 맞게 수행한다.
* I/O 작업이 없다면 바로 CPU 작업을 시행하는 것이 아니라 각 알고리즘에 따라 준비 큐에서 선점 가능한 프로세스가 있는지 확인해야한다. 선점 가능한 프로세스가 있으면 현재 프로세스는 준비 큐로 보내며 READY상태가 되고, 선점하는 프로세스는 RUNNING상태로 변한다.
* 최종적으로 실행할 프로세스에 대해 I/O, CPU 실행을 진행하고 간트 차트에 기록한다.

**[round_robin]**
* 현재 실행 중인 프로세스를 찾는다.
* 현재 실행 중인 프로세스가 없지만 준비 큐에 프로세스가 있는 경우 준비 큐에서 들어온 순서대로 바로 다음 프로세스를 꺼내와서 RUNNING상태로 만든다.
* 실행 중인 프로세스를 찾은 경우 I/O 작업을 해야하면 대기 큐로 옮기고 준비 큐에 프로세스가 있는지 확인한다.
* 준비 큐에 프로세스가 있는 경우 다음 프로세스를 바로 선택한다. 이 때 다음 프로세스를 선택하는 과정 또한 대기 큐에 온 순서대로 선택한다.
* 최종적으로 선택한 프로세스를 실행하고 cur_used_quantum을 1 증가시킨다. 이 값은 현재 프로세스가 정해진 타임 퀀텀값까지만 연속으로 CPU를 사용할 수 있게 한다.
* 만약 사용된 타임 퀀텀값이 시스템의 정해진 타임 퀀텀값과 같아지면 cur_used_quantum을 0으로 초기화하고 준비 큐에서 다음 프로세스를 골라서 RUNNING 상태로 바꾸고 현재 진행 중인 프로세스는 READY 상태로 준비 큐의 제일 뒤로 넣는다.
* 최종적으로 실행할 프로세스에 대해 I/O, CPU 실행을 진행하고 간트 차트에 기록한다.

### 2.4 알고리즘들 간의 성능 비교
평균 반환 시간은 SJF 선점형이 23.70으로 가장 짧고, 그다음 SJF 비선점형이 24.70,. FCFS는 30.30, Priority 비선점형은 32.00, Priority 선점형은 32.90, Round Robin은 38.70으로 가장 길다. 이는 시뮬레이터에서 타임 퀀텀을 2초로 설정해놓았지만 들어오는 프로세스의 CPU 버스트 시간은 대부분 10초 정도이기 때문에 대략 5번의 전환이 필요하다. 이로 인해 각 프로세스가 자신의 차례를 받기 위해 오래 기다리며 프로세스가 종료되기 까지 많은 시간이 필요하게 된다.

대기 시간 기준으로도 SJF 선점형이 16.00으로 가장 짧고, SJF 비선점형이 17.00, FCFS는 22.60, Priority 비선점형은 24.30, Priority 선점형은 25.20, Round Robin은 31.00으로 가장 길다. 이는 평균 반환 시간의 경우와 비슷하다. 타임 퀀텀이 작기 때문에 프로세스의 대기 시간이 길 수밖에 없다.

또한 Priority 스케줄링에서 비선점형이 선점형보다 성능이 좋게 나왔는데. 이는 과도한 선점으로 인해 프로세스가 종료되지 못하고 다른 프로세스에 의해 선점되어 대기 시간이 늘어날 수 있게 되었다. 예를 들어, P6의 경우 Priority 비선점형에서는 반환시간 9시간이었지만 선점형에서는 32시간으로 크게 증가했다.
